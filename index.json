[{"content":" AI时代, 用户忠诚度为零\n随着越来越多 AI 工具的出现，在日常使用 Cursor 时，真正依赖的功能只剩下 Tab 补全 和 项目总结。因此，在使用 10 个月后，我决定退订。\n最初接触 Cursor 是去年，通过 X 上的讨论和同事的推荐。当时我一直在用 VSCode，配合 GitHub Copilot。抱着好奇心，我立刻注册了 Cursor 并体验了一段时间。Cursor确实是划时代的产品，试用期结束后，直接续订了月付，没有选择更优惠的年付方案，相信 AI 工具会高速迭代，保持灵活性更重要。\n同时，也没有去淘宝购买低价账号。一方面是想培养自己的付费意识；另一方面也清楚这种订阅模式本质上是“大家一起承担成本”的生态——如果所有人都只白嫖，工具可能就无法持续发展。某种程度上，每个白嫖用户都该对付费用户说声谢谢 😂。\n从后续的产品调整也能看出来这一点：Cursor 频繁地修改 Token 策略，其实就是在平衡订阅制和按量计费的成本之间的矛盾。\n取消订阅后，如果 Cursor 在免费模式下不限制基本的编辑器功能，会继续使用它；但如果限制过多，我将会回到 VSCode，或者其他类 VSCode 编辑器。\n","permalink":"https://gaoxin19.github.io/post/cursor-unsubscribe-10-months/","summary":"\u003cblockquote\u003e\n\u003cp\u003eAI时代, 用户忠诚度为零\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e随着越来越多 AI 工具的出现，在日常使用 Cursor 时，真正依赖的功能只剩下 \u003cstrong\u003eTab 补全\u003c/strong\u003e 和 \u003cstrong\u003e项目总结\u003c/strong\u003e。因此，在使用 10 个月后，我决定退订。\u003c/p\u003e\n\u003cp\u003e最初接触 Cursor 是去年，通过 X 上的讨论和同事的推荐。当时我一直在用 VSCode，配合 GitHub Copilot。抱着好奇心，我立刻注册了 Cursor 并体验了一段时间。Cursor确实是划时代的产品，试用期结束后，直接续订了月付，没有选择更优惠的年付方案，相信 AI 工具会高速迭代，保持灵活性更重要。\u003c/p\u003e","title":"订阅10个月后，和Cursor说再见"},{"content":"1. JOIN的统一模型：笛卡尔积与过滤 要理解任何 JOIN 的性能，必须回归其最根本的数学模型。无论是 INNER JOIN 还是 OUTER JOIN，其逻辑上都可以分解为以下步骤：\n生成组合 (Combination)：计算两张表的笛卡尔积（Cartesian Product），即 表A行数 × 表B行数 的全量组合。 应用条件 (Filtering)：使用 ON 子句作为过滤器，在全量组合中筛选出满足条件的行。 补充数据 (Augmentation - 仅外连接)：对于 OUTER JOIN，需要将“保留表”（如 LEFT JOIN 中的左表）中未能匹配的行补充回来，并将另一表的字段填充为 NULL。 这个模型可以用以下流程图来概念化：\n--- config: theme: neutral --- flowchart TD subgraph \u0026#34;JOIN 逻辑模型\u0026#34; direction TB A[\u0026#34;表 A (M行)\u0026#34;] B[\u0026#34;表 B (N行)\u0026#34;] subgraph \u0026#34;1. 组合\u0026#34; C((笛卡尔积 M*N)) end subgraph \u0026#34;2. 过滤\u0026#34; F{ON 条件} end subgraph \u0026#34;3. 补充 (外连接)\u0026#34; G[为A中未匹配行\u0026lt;br/\u0026gt;补NULL] end A --\u0026gt; C B --\u0026gt; C C --\u0026gt; F F -- 匹配 --\u0026gt; D[匹配行] F -- A中未匹配 --\u0026gt; G D --\u0026gt; E_INNER[\u0026lt;b\u0026gt;INNER JOIN 结果\u0026lt;/b\u0026gt;] D --\u0026gt; E_LEFT[\u0026lt;b\u0026gt;LEFT JOIN 结果\u0026lt;/b\u0026gt;] G --\u0026gt; E_LEFT end 虽然数据库的查询优化器 (Query Optimizer) 极少会真正执行一次完整的笛卡尔积，但这个模型是理解所有 JOIN 行为和性能问题的基石。\n2. 核心误区：结果集大小 vs. 执行成本 这里外连接只用LEFT JOIN举例，相比 RIGHT JOIN 仅是左右的区别\n常见误解：LEFT JOIN 的结果集通常 ≥ INNER JOIN，因此 LEFT JOIN 的开销更大。\n事实：查询性能的核心驱动因素是执行计划的成本 (Execution Cost)，而非最终结果集的大小。执行成本主要由 I/O、CPU 计算和内存使用决定。一个低效的执行计划，即使最终只返回一行数据，也可能扫描了数十亿行，其成本是巨大的。 INNER JOIN 和 LEFT JOIN 的关键性能差异，在于优化器选择执行计划的灵活性和确定性。\nINNER JOIN：优化器拥有完全的自主权。它可以在 A JOIN B 和 B JOIN A 之间自由选择，决定哪张表作为驱动表 (Driving Table)，哪张作为被驱动表 (Driven Table)。如果优化器基于错误的统计信息做出了误判（例如，错误地将大表作为驱动表），就可能导致灾难性的性能。\nLEFT JOIN：优化器的选择在逻辑上受到了限制。左表天然就是驱动表。这个“限制”在某些场景下反而成了一种优势，因为它提供了一个稳定、可预测的执行路径：遍历左表的每一行，然后去右表进行查找。\n3. 场景分析：后台列表的关联筛选 通过关联表筛选主列表（Bot与用户启用关系），这是一个典型的“多对多”关联查询场景。\n数据模型: bots 表: 包含所有可用的 Bot (id, name, \u0026hellip;)。这是一个主数据列表。 bot_user_relations 表: 记录了哪个用户启用了哪个 Bot (id, bot_id, user_id)。这是一个关联表。 新增需求: 在后台的“Bot 列表”页面，增加一个筛选条件，可以根据 user_id 查询出该用户已启用的所有 Bot。 方案一：使用 INNER JOIN (逻辑正确，性能最优) 这个需求的本质是求两个集合的交集：“所有 Bot 的集合”与“某个特定用户启用的 Bot 的集合”。INNER JOIN 正是为此而生。\nSELECT b.* FROM bots b INNER JOIN bot_user_relations r ON b.id = r.bot_id WHERE r.user_id = 123; 执行计划分析: 这个查询的意图非常清晰，优化器可以轻松地制定出最高效的执行计划。假设 bot_user_relations 表的 user_id 字段上有索引：\n驱动: 优化器会首先在 bot_user_relations 表上应用 WHERE r.user_id = 123 条件。通过 user_id 索引，它能以极高的速度定位到该用户启用的所有记录。这通常是一个非常小的数据集。 连接: 然后，优化器会拿着这个小结果集中的 bot_id，去 bots 表中查找对应的 Bot 详细信息。由于是通过主键 b.id 进行连接，这个查找过程同样快如闪电。 结论: 这个方案的执行路径是“先过滤，再连接”。它从最小的数据集开始驱动整个查询，最大限度地减少了 I/O 和计算量，是实现该需求最理想的方式。\n方案二：使用 LEFT JOIN (逻辑误导，结果相同但意图不明) 开发者有时会陷入一种思维定式：“我的主列表是 bots 表，所以我应该从它开始，用 LEFT JOIN。”\nSELECT b.* FROM bots b LEFT JOIN bot_user_relations r ON b.id = r.bot_id WHERE r.user_id = 123; 执行计划分析: WHERE 子句中对右表 r 的过滤条件 (r.user_id = 123)，会自动将所有在 r 表中没有匹配的行（这些行的 r.user_id 为 NULL）给排除掉。\n因此，这个查询的最终结果集与 INNER JOIN 完全一致。\n虽然现代优化器通常会将其重写为 INNER JOIN 并采用相同的最优执行计划，但这种写法存在问题：\n代码意图不清晰: 代码表面上是想保留所有 bots，但实际上却是在做过滤。 依赖优化器: 你将代码的正确性寄希望于优化器的智能，这是一个潜在的风险。在某些极端复杂的查询或特定数据库版本中，优化器可能无法做出最优转换，导致性能下降。 LEFT JOIN 在此场景下的真正用途：状态标记 LEFT JOIN 在这里的正确用法不是筛选，而是为全量列表增加状态标记。例如，需求是：“显示所有 Bot，并标记出哪些是用户 123 启用的”。\nSELECT b.id, b.name, -- 如果 r.user_id 不为 NULL，说明关联成功，即用户已启用 (CASE WHEN r.user_id IS NOT NULL THEN \u0026#39;Yes\u0026#39; ELSE \u0026#39;No\u0026#39; END) AS is_enabled_by_user_123 FROM bots b LEFT JOIN bot_user_relations r ON b.id = r.bot_id AND r.user_id = 123; 注意关键区别：r.user_id = 123 这个条件被移入了 ON 子句。\nON 子句中的条件: 定义了“如何关联”。这里的意思是，不仅 bot_id 要匹配，user_id 也必须是 123，才算是一次成功的连接。 WHERE 子句中的条件: 定义了“如何过滤最终结果集”。 这个查询会返回 bots 表中的所有记录，并通过一个额外的 is_enabled 字段清晰地展示了每个 Bot 对于特定用户的启用状态。这才是 LEFT JOIN 在此场景下强大而正确的应用。\n4. 总结与实践建议 哪种JOIN类型更快，并非普适规则，而是在特定条件下的必然结果。\n对比维度 INNER JOIN LEFT JOIN 核心逻辑 返回两表的交集 返回左表全集，并附带右表的匹配信息 优化器行为 灵活：可自由选择驱动表和连接算法（Hash, Nested Loop等） 受约束：左表在逻辑上强制为驱动表 性能优势场景 ON 条件高选择性，能通过索引快速过滤掉大量数据 左表驱动为最优选择，且右表匹配稀疏或不确定 潜在风险 优化器可能因统计数据过时或复杂查询而选错执行计划 如果右表是小表，强制左表（大表）驱动可能并非最优 第一性原理总结 (Key Takeaways): 性能瓶颈在于过程，而非结果：始终关注 EXPLAIN 展示的执行计划，而不是结果集的行数。 JOIN 的性能核心在于“驱动”与“查找”的成本：选择最优的驱动表，并确保对被驱动表的查找是高效的（通常意味着利用索引）。 LEFT JOIN 的优势在于“确定性”：当你知道“扫描左表，查找右表”是最佳路径时，LEFT JOIN 能确保优化器就走这条路，从而避免了不确定性带来的风险。 按需使用：不要因为潜在的性能优势而滥用 LEFT JOIN。如果你的业务逻辑只需要交集，就应该使用 INNER JOIN，并确保相关的列上有正确的索引，既要相信优化器的判断，也要善用 EXPLAIN 去验证它。 ","permalink":"https://gaoxin19.github.io/post/from-cartesian-product-sql-join-performance/","summary":"\u003ch3 id=\"1-join的统一模型笛卡尔积与过滤\"\u003e\u003cstrong\u003e1. JOIN的统一模型：笛卡尔积与过滤\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e要理解任何 \u003ccode\u003eJOIN\u003c/code\u003e 的性能，必须回归其最根本的数学模型。无论是 \u003ccode\u003eINNER JOIN\u003c/code\u003e 还是 \u003ccode\u003eOUTER JOIN\u003c/code\u003e，其逻辑上都可以分解为以下步骤：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e生成组合 (Combination)\u003c/strong\u003e：计算两张表的笛卡尔积（Cartesian Product），即 \u003ccode\u003e表A行数 × 表B行数\u003c/code\u003e 的全量组合。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e应用条件 (Filtering)\u003c/strong\u003e：使用 \u003ccode\u003eON\u003c/code\u003e 子句作为过滤器，在全量组合中筛选出满足条件的行。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e补充数据 (Augmentation - 仅外连接)\u003c/strong\u003e：对于 \u003ccode\u003eOUTER JOIN\u003c/code\u003e，需要将“保留表”（如 \u003ccode\u003eLEFT JOIN\u003c/code\u003e 中的左表）中未能匹配的行补充回来，并将另一表的字段填充为 \u003ccode\u003eNULL\u003c/code\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e这个模型可以用以下流程图来概念化：\u003c/p\u003e","title":"从笛卡尔积看 SQL JOIN 性能"},{"content":"记录跨域问题的原因，并展示如何使用 Nginx 的配置来解决这些问题\n什么是跨源资源共享（CORS）？ 跨源资源共享（CORS）是一种浏览器安全策略，用于限制来自不同域的 Web 应用程序对当前域中资源的访问。想要深入了解 CORS，请查阅MDN Web 文档。\n跨域问题与 Nginx 配置 当前端直接请求服务端接口时，经常会遇到跨域问题，你可能会在浏览器的控制台看到如下错误：\nAccess to XMLHttpRequest at \u0026lsquo;https://test.xxx.com\u0026rsquo; from origin \u0026lsquo;http://localhost:8080\u0026rsquo; has been blocked by CORS policy: Response to preflight request doesn\u0026rsquo;t pass access control check: No \u0026lsquo;Access-Control-Allow-Origin\u0026rsquo; header is present on the requested resource.\n在使用 Nginx 作为反向代理时，我们一般可以通过以下配置解决大多数跨域问题：\nlocation / { ... add_header Access-Control-Allow-Origin \u0026#34;https://localhost:8080\u0026#34;; add_header Access-Control-Allow-Credentials true; add_header Access-Control-Expose-Headers FooBar; ... } 然而，有一些特殊情况需要额外注意，我们将逐一列举并给出相应的优化配置。\n其他情况 情况一，Nginx反向代理服务端，服务端也进行了跨域设置 此时可能会出现以下错误:\nAccess to XMLHttpRequest at \u0026lsquo;https://test.xxx.com/api/xxx' from origin \u0026lsquo;http://localhost:8080\u0026rsquo; has been blocked by CORS policy: Response to preflight request doesn\u0026rsquo;t pass access control check: The \u0026lsquo;Access-Control-Allow-Origin\u0026rsquo; header contains multiple values \u0026lsquo;http://localhost:8080, *\u0026rsquo;, but only one is allowed.\n可以考虑移除服务端的跨域设置\n或在Nginx中对Access-Control-Allow-Origin进行修改而不是添加，即：\n使用proxy_set_header而不是add_header\nlocation / { ... proxy_set_header Access-Control-Allow-Origin *; ... } 情况二，服务端（或框架）对于预检请求没有特殊处理 预检请求（Preflight Request）是 CORS 中的一种特殊请求，关于预检请求的详细信息请参考这里。\n在这种情况下，客户端对服务端发起 OPTIONS 请求时可能出现 404 错误，或者收到其他正常响应但没有任何 CORS 相关的头信息字段。这时，浏览器会认定服务器不同意预检请求，从而导致跨域问题。\n解决方案是在 Nginx 中添加如下配置：\nlocation / { ... if ($request_method = \u0026#39;OPTIONS\u0026#39;) { return 204; } ... } 情况三，需要使用Cookie，但配置了Access-Control-Allow-Origin: * 一般这种情况需要使用 cookie，所以配置了Access-Control-Allow-Credentials: true，或客户端使用了withCredentials = true\nAccess-Control-Allow-Credentials：该字段是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。\n会出现如下报错:\nAccess to XMLHttpRequest at \u0026lsquo;https://test.xxx.com/api/xxx' from origin \u0026lsquo;http://localhost:8080\u0026rsquo; has been blocked by CORS policy: Response to preflight request doesn\u0026rsquo;t pass access control check: The value of the \u0026lsquo;Access-Control-Allow-Origin\u0026rsquo; header in the response must not be the wildcard \u0026lsquo;*\u0026rsquo; when the request\u0026rsquo;s credentials mode is \u0026lsquo;include\u0026rsquo;. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.\n为了解决这个问题，我们不能使用 *，而必须指定具体的 Origin。\n如果你有确定的域名，可以直接将其写入配置中：\nlocation / { ... add_header Access-Control-Allow-Origin http://xxx.com; ... } 如果你需要根据相关规则动态设置 Origin：\nlocation / { ... if ($http_origin ~* \u0026#34;xxx.com\u0026#34;) { add_header Access-Control-Allow-Origin $http_origin; } ... } 情况四，配置顺序不对 在代理的资源后面加跨域参数无效\nlocation / { proxy_pass http://test.xxx.com/api # ❌写在这里不会生效 ... add_header Access-Control-Allow-Origin $http_origin; ... proxy_pass http://test.xxx.com/api # ✅要写在参数配置下方 } 参考链接 跨域资源共享 CORS 详解 https://www.ruanyifeng.com/blog/2016/04/cors.html\nNginx 轻松搞定跨域问题！https://www.cnblogs.com/konglxblog/p/16114550.html\n","permalink":"https://gaoxin19.github.io/post/cors_problems/","summary":"\u003cp\u003e记录跨域问题的原因，并展示如何使用 Nginx 的配置来解决这些问题\u003c/p\u003e\n\u003cp\u003e什么是跨源资源共享（CORS）？\n跨源资源共享（CORS）是一种浏览器安全策略，用于限制来自不同域的 Web 应用程序对当前域中资源的访问。想要深入了解 CORS，请查阅\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS\"\u003eMDN Web 文档\u003c/a\u003e。\u003c/p\u003e","title":"跨域问题记录"},{"content":"数学定义 众所周知，三点确定一个圆，通过在圆上的任意三点可以解出圆的方程，当我们解出方程，一般会得到数学中常见的一般式方程：\n$$x^2+y^2+Dx+Ey+F=r^2$$\n本质上我们也得到了圆心和半径（可能并不那么容易）\n已知圆心 (x0, y0) 和半径 r，可以得到圆的标准方程：\n$${(x-x0)}^2+{(y-y0)}^2=r^2$$\n制作圆的动画的关键就需要得到圆心和半径, 可以想象下圆规画圆\n圆周动画 做动画和数学中解方程不完全相同，动画还有一个进度的概念，进度大部分时候可以理解为时间，不同时间中的状态组成了动画\n使物体做圆周运动，需要得到物体在圆周上不同时间的坐标\n假设物体的起始坐标为 (r, 0)，初始角度为 0，在单位时间内移动的角度为 θ\n那么在下一个单位时间的坐标为 (r*cosθ, r*sinθ)，随着时间角度不断增加，就可以得到一个圆的动画\n这里演示用，我们使 θ = π/6（弧度制），即30度\n不断点击下方canvas画布可以得到这个过程\n弧度制和角度制 角度是客观存在的, 具体数值则是一个度量标准。数学中三角函数使用的是弧度制，编程语言中也使用弧度制。\n角度制是把周角映射到360°，弧度制是把周角映射到2π，可以得到 $$2πrad=360° $$ $$πrad=180° $$ $$rad=\\frac{180°}{π}$$\n例：js将角度转为弧度\nconst angle = 30 const rad = 30 * Math.PI / 180 Math.sin(rad) // 0.49999999999999994 ","permalink":"https://gaoxin19.github.io/post/circle_animation/","summary":"\u003ch3 id=\"数学定义\"\u003e数学定义\u003c/h3\u003e\n\u003cp\u003e众所周知，\u003cstrong\u003e三点确定一个圆\u003c/strong\u003e，通过在圆上的任意三点可以解出圆的方程，当我们解出方程，一般会得到数学中常见的一般式方程：\u003c/p\u003e\n\u003cp\u003e$$x^2+y^2+Dx+Ey+F=r^2$$\u003c/p\u003e\n\u003cp\u003e本质上我们也得到了圆心和半径（可能并不那么容易）\u003c/p\u003e","title":"圆周运动动画"},{"content":"Hugo是一个用Go语言编写的静态网站生成器，想了解Hugo可以前往官网。\n这次使用Hugo来写博客，并发布到github pages，之前就用Jekyll搞过一次（没写起来）。\n为什么要用Hugo?\n放在今天已经不算新鲜，但对我来说，主要就是图一新鲜（我没整过），其实Jekyll用起来也很简单，网上的教程几乎都是手把手教学。有个趁手的工具持续输出内容才是关键。\n安装Hugo 官网有介绍，我这次选择源码安装(MacOS)\nmkdir $HOME/src cd $HOME/src git clone https://github.com/gohugoio/hugo.git cd hugo go install go build -o hugo main.go 执行以上命令后在$HOME/src中会有一个hugo的可执行文件，添加到环境变量，(我的shell是zsh)在 ~/.zshrc中添加以下内容后执行source ~/.zshrc\nexport HUGO_HOME=\u0026#34;$HOME/src/hugo\u0026#34; export PATH=\u0026#34;$HUGO_HOME:$PATH\u0026#34; 在命令行中输入hugo version验证是否安装成功\n使用 创建项目\nhugo new site my-site-name 创建后的hugo项目是没有主题的，但是需要主题才能使用\n到这个网站查看主题，选择一个中意的进行下载，我这里选择了一个简单的主题Blonde\ncd my-site-name git init git submodule add https://github.com/opera7133/Blonde.git themes/Blonde 按照主题页面的指引安装，配置文件主题已经提供了示例，直接copy到项目根目录，不同的主题安装略有差异，具体请查看页面上的介绍\n启动Hugo服务\nhugo server --buildDrafts --watch \u0026ndash;buildDrafts或者-D，可以查看草稿内容\n-–watch或者-w 选项打开的话，将会监控到内容的改动从而自动去刷新浏览器\n服务起来后，进入http://localhost:1313查看\n页面是空的，因为还没有内容\n添加内容\nhugo new posts/test.md 打开文件顶部是以下内容\n--- title: \u0026#34;test\u0026#34; date: 2022-09-20T12:18:38+08:00 draft: true --- 注意发布的时候要把draft设为false，即标记为不是草稿\n发布到Github Pages上 我创建了两个仓库，一个放hugo项目，用来写博客，可能会有不完整的草稿，就设置为了私有。另一个用来部署github pages\n在hugo项目中打包，将生成的pullic项目推送到github pages项目，操作如下:\nhugo cd public git init git remote add origin git@github.com:xinyan818/xinyan818.github.io.git git add -A git commit -m \u0026#39;public\u0026#39; git push --set-upstream origin master 非首次执行，git init会提示已存在仓库，忽略就可以\n","permalink":"https://gaoxin19.github.io/post/blog_with_hugo/","summary":"\u003cp\u003eHugo是一个用Go语言编写的静态网站生成器，想了解\u003ccode\u003eHugo\u003c/code\u003e可以\u003ca href=\"https://gohugo.io/\"\u003e前往官网\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e这次使用Hugo来写博客，并发布到github pages，之前就用\u003ccode\u003eJekyll\u003c/code\u003e搞过一次（没写起来）。\u003c/p\u003e","title":"使用Hugo建立博客"},{"content":"","permalink":"https://gaoxin19.github.io/contact/","summary":"","title":"Contact"},{"content":"一个普通人\n","permalink":"https://gaoxin19.github.io/about/","summary":"\u003cp\u003e一个普通人\u003c/p\u003e","title":"About"}]
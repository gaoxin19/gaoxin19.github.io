<!doctype html><html lang=zh dir=ltr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>从笛卡尔积看 SQL JOIN 性能 | 胡思乱</title><meta name=keywords content="SQL"><meta name=description content="1. JOIN的统一模型：笛卡尔积与过滤
要理解任何 JOIN 的性能，必须回归其最根本的数学模型。无论是 INNER JOIN 还是 OUTER JOIN，其逻辑上都可以分解为以下步骤：

生成组合 (Combination)：计算两张表的笛卡尔积（Cartesian Product），即 表A行数 × 表B行数 的全量组合。
应用条件 (Filtering)：使用 ON 子句作为过滤器，在全量组合中筛选出满足条件的行。
补充数据 (Augmentation - 仅外连接)：对于 OUTER JOIN，需要将“保留表”（如 LEFT JOIN 中的左表）中未能匹配的行补充回来，并将另一表的字段填充为 NULL。

这个模型可以用以下流程图来概念化："><meta name=author content="Me"><link rel=canonical href=https://gaoxin19.github.io/post/from-cartesian-product-sql-join-performance/><link crossorigin=anonymous href=/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css integrity="sha256-IhHKMWS+eDACT2qtKzouUghDpk+PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as=style><link rel=icon href=https://gaoxin19.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://gaoxin19.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://gaoxin19.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://gaoxin19.github.io/apple-touch-icon.png><link rel=mask-icon href=https://gaoxin19.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://gaoxin19.github.io/post/from-cartesian-product-sql-join-performance/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=module>
    import mermaid from "https:\/\/cdn.jsdelivr.net\/npm\/mermaid@latest\/dist\/mermaid.esm.min.mjs";
  </script><style>@media screen and (min-width:769px){.post-content input[type=checkbox]:checked~label>img{transform:scale(1.6);cursor:zoom-out;position:relative;z-index:999}.post-content img.zoomCheck{transition:transform .15s ease;z-index:999;cursor:zoom-in}}</style><meta property="og:url" content="https://gaoxin19.github.io/post/from-cartesian-product-sql-join-performance/"><meta property="og:site_name" content="胡思乱"><meta property="og:title" content="从笛卡尔积看 SQL JOIN 性能"><meta property="og:description" content="1. JOIN的统一模型：笛卡尔积与过滤 要理解任何 JOIN 的性能，必须回归其最根本的数学模型。无论是 INNER JOIN 还是 OUTER JOIN，其逻辑上都可以分解为以下步骤：
生成组合 (Combination)：计算两张表的笛卡尔积（Cartesian Product），即 表A行数 × 表B行数 的全量组合。 应用条件 (Filtering)：使用 ON 子句作为过滤器，在全量组合中筛选出满足条件的行。 补充数据 (Augmentation - 仅外连接)：对于 OUTER JOIN，需要将“保留表”（如 LEFT JOIN 中的左表）中未能匹配的行补充回来，并将另一表的字段填充为 NULL。 这个模型可以用以下流程图来概念化："><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-08-21T12:10:38+08:00"><meta property="article:modified_time" content="2025-08-21T12:10:38+08:00"><meta property="article:tag" content="SQL"><meta name=twitter:card content="summary"><meta name=twitter:title content="从笛卡尔积看 SQL JOIN 性能"><meta name=twitter:description content="1. JOIN的统一模型：笛卡尔积与过滤
要理解任何 JOIN 的性能，必须回归其最根本的数学模型。无论是 INNER JOIN 还是 OUTER JOIN，其逻辑上都可以分解为以下步骤：

生成组合 (Combination)：计算两张表的笛卡尔积（Cartesian Product），即 表A行数 × 表B行数 的全量组合。
应用条件 (Filtering)：使用 ON 子句作为过滤器，在全量组合中筛选出满足条件的行。
补充数据 (Augmentation - 仅外连接)：对于 OUTER JOIN，需要将“保留表”（如 LEFT JOIN 中的左表）中未能匹配的行补充回来，并将另一表的字段填充为 NULL。

这个模型可以用以下流程图来概念化："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://gaoxin19.github.io/post/"},{"@type":"ListItem","position":2,"name":"从笛卡尔积看 SQL JOIN 性能","item":"https://gaoxin19.github.io/post/from-cartesian-product-sql-join-performance/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"从笛卡尔积看 SQL JOIN 性能","name":"从笛卡尔积看 SQL JOIN 性能","description":"1. JOIN的统一模型：笛卡尔积与过滤 要理解任何 JOIN 的性能，必须回归其最根本的数学模型。无论是 INNER JOIN 还是 OUTER JOIN，其逻辑上都可以分解为以下步骤：\n生成组合 (Combination)：计算两张表的笛卡尔积（Cartesian Product），即 表A行数 × 表B行数 的全量组合。 应用条件 (Filtering)：使用 ON 子句作为过滤器，在全量组合中筛选出满足条件的行。 补充数据 (Augmentation - 仅外连接)：对于 OUTER JOIN，需要将“保留表”（如 LEFT JOIN 中的左表）中未能匹配的行补充回来，并将另一表的字段填充为 NULL。 这个模型可以用以下流程图来概念化：\n","keywords":["SQL"],"articleBody":"1. JOIN的统一模型：笛卡尔积与过滤 要理解任何 JOIN 的性能，必须回归其最根本的数学模型。无论是 INNER JOIN 还是 OUTER JOIN，其逻辑上都可以分解为以下步骤：\n生成组合 (Combination)：计算两张表的笛卡尔积（Cartesian Product），即 表A行数 × 表B行数 的全量组合。 应用条件 (Filtering)：使用 ON 子句作为过滤器，在全量组合中筛选出满足条件的行。 补充数据 (Augmentation - 仅外连接)：对于 OUTER JOIN，需要将“保留表”（如 LEFT JOIN 中的左表）中未能匹配的行补充回来，并将另一表的字段填充为 NULL。 这个模型可以用以下流程图来概念化：\n--- config: theme: neutral --- flowchart TD subgraph \"JOIN 逻辑模型\" direction TB A[\"表 A (M行)\"] B[\"表 B (N行)\"] subgraph \"1. 组合\" C((笛卡尔积 M*N)) end subgraph \"2. 过滤\" F{ON 条件} end subgraph \"3. 补充 (外连接)\" G[为A中未匹配行补NULL] end A --\u003e C B --\u003e C C --\u003e F F -- 匹配 --\u003e D[匹配行] F -- A中未匹配 --\u003e G D --\u003e E_INNER[INNER JOIN 结果] D --\u003e E_LEFT[LEFT JOIN 结果] G --\u003e E_LEFT end 虽然数据库的查询优化器 (Query Optimizer) 极少会真正执行一次完整的笛卡尔积，但这个模型是理解所有 JOIN 行为和性能问题的基石。\n2. 核心误区：结果集大小 vs. 执行成本 这里外连接只用LEFT JOIN举例，相比 RIGHT JOIN 仅是左右的区别\n常见误解：LEFT JOIN 的结果集通常 ≥ INNER JOIN，因此 LEFT JOIN 的开销更大。\n事实：查询性能的核心驱动因素是执行计划的成本 (Execution Cost)，而非最终结果集的大小。执行成本主要由 I/O、CPU 计算和内存使用决定。一个低效的执行计划，即使最终只返回一行数据，也可能扫描了数十亿行，其成本是巨大的。 INNER JOIN 和 LEFT JOIN 的关键性能差异，在于优化器选择执行计划的灵活性和确定性。\nINNER JOIN：优化器拥有完全的自主权。它可以在 A JOIN B 和 B JOIN A 之间自由选择，决定哪张表作为驱动表 (Driving Table)，哪张作为被驱动表 (Driven Table)。如果优化器基于错误的统计信息做出了误判（例如，错误地将大表作为驱动表），就可能导致灾难性的性能。\nLEFT JOIN：优化器的选择在逻辑上受到了限制。左表天然就是驱动表。这个“限制”在某些场景下反而成了一种优势，因为它提供了一个稳定、可预测的执行路径：遍历左表的每一行，然后去右表进行查找。\n3. 场景分析：后台列表的关联筛选 通过关联表筛选主列表（Bot与用户启用关系），这是一个典型的“多对多”关联查询场景。\n数据模型: bots 表: 包含所有可用的 Bot (id, name, …)。这是一个主数据列表。 bot_user_relations 表: 记录了哪个用户启用了哪个 Bot (id, bot_id, user_id)。这是一个关联表。 新增需求: 在后台的“Bot 列表”页面，增加一个筛选条件，可以根据 user_id 查询出该用户已启用的所有 Bot。 方案一：使用 INNER JOIN (逻辑正确，性能最优) 这个需求的本质是求两个集合的交集：“所有 Bot 的集合”与“某个特定用户启用的 Bot 的集合”。INNER JOIN 正是为此而生。\nSELECT b.* FROM bots b INNER JOIN bot_user_relations r ON b.id = r.bot_id WHERE r.user_id = 123; 执行计划分析: 这个查询的意图非常清晰，优化器可以轻松地制定出最高效的执行计划。假设 bot_user_relations 表的 user_id 字段上有索引：\n驱动: 优化器会首先在 bot_user_relations 表上应用 WHERE r.user_id = 123 条件。通过 user_id 索引，它能以极高的速度定位到该用户启用的所有记录。这通常是一个非常小的数据集。 连接: 然后，优化器会拿着这个小结果集中的 bot_id，去 bots 表中查找对应的 Bot 详细信息。由于是通过主键 b.id 进行连接，这个查找过程同样快如闪电。 结论: 这个方案的执行路径是“先过滤，再连接”。它从最小的数据集开始驱动整个查询，最大限度地减少了 I/O 和计算量，是实现该需求最理想的方式。\n方案二：使用 LEFT JOIN (逻辑误导，结果相同但意图不明) 开发者有时会陷入一种思维定式：“我的主列表是 bots 表，所以我应该从它开始，用 LEFT JOIN。”\nSELECT b.* FROM bots b LEFT JOIN bot_user_relations r ON b.id = r.bot_id WHERE r.user_id = 123; 执行计划分析: WHERE 子句中对右表 r 的过滤条件 (r.user_id = 123)，会自动将所有在 r 表中没有匹配的行（这些行的 r.user_id 为 NULL）给排除掉。\n因此，这个查询的最终结果集与 INNER JOIN 完全一致。\n虽然现代优化器通常会将其重写为 INNER JOIN 并采用相同的最优执行计划，但这种写法存在问题：\n代码意图不清晰: 代码表面上是想保留所有 bots，但实际上却是在做过滤。 依赖优化器: 你将代码的正确性寄希望于优化器的智能，这是一个潜在的风险。在某些极端复杂的查询或特定数据库版本中，优化器可能无法做出最优转换，导致性能下降。 LEFT JOIN 在此场景下的真正用途：状态标记 LEFT JOIN 在这里的正确用法不是筛选，而是为全量列表增加状态标记。例如，需求是：“显示所有 Bot，并标记出哪些是用户 123 启用的”。\nSELECT b.id, b.name, -- 如果 r.user_id 不为 NULL，说明关联成功，即用户已启用 (CASE WHEN r.user_id IS NOT NULL THEN 'Yes' ELSE 'No' END) AS is_enabled_by_user_123 FROM bots b LEFT JOIN bot_user_relations r ON b.id = r.bot_id AND r.user_id = 123; 注意关键区别：r.user_id = 123 这个条件被移入了 ON 子句。\nON 子句中的条件: 定义了“如何关联”。这里的意思是，不仅 bot_id 要匹配，user_id 也必须是 123，才算是一次成功的连接。 WHERE 子句中的条件: 定义了“如何过滤最终结果集”。 这个查询会返回 bots 表中的所有记录，并通过一个额外的 is_enabled 字段清晰地展示了每个 Bot 对于特定用户的启用状态。这才是 LEFT JOIN 在此场景下强大而正确的应用。\n4. 总结与实践建议 哪种JOIN类型更快，并非普适规则，而是在特定条件下的必然结果。\n对比维度 INNER JOIN LEFT JOIN 核心逻辑 返回两表的交集 返回左表全集，并附带右表的匹配信息 优化器行为 灵活：可自由选择驱动表和连接算法（Hash, Nested Loop等） 受约束：左表在逻辑上强制为驱动表 性能优势场景 ON 条件高选择性，能通过索引快速过滤掉大量数据 左表驱动为最优选择，且右表匹配稀疏或不确定 潜在风险 优化器可能因统计数据过时或复杂查询而选错执行计划 如果右表是小表，强制左表（大表）驱动可能并非最优 第一性原理总结 (Key Takeaways): 性能瓶颈在于过程，而非结果：始终关注 EXPLAIN 展示的执行计划，而不是结果集的行数。 JOIN 的性能核心在于“驱动”与“查找”的成本：选择最优的驱动表，并确保对被驱动表的查找是高效的（通常意味着利用索引）。 LEFT JOIN 的优势在于“确定性”：当你知道“扫描左表，查找右表”是最佳路径时，LEFT JOIN 能确保优化器就走这条路，从而避免了不确定性带来的风险。 按需使用：不要因为潜在的性能优势而滥用 LEFT JOIN。如果你的业务逻辑只需要交集，就应该使用 INNER JOIN，并确保相关的列上有正确的索引，既要相信优化器的判断，也要善用 EXPLAIN 去验证它。 ","wordCount":"2564","inLanguage":"zh","datePublished":"2025-08-21T12:10:38+08:00","dateModified":"2025-08-21T12:10:38+08:00","author":[{"@type":"Person","name":"Me"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://gaoxin19.github.io/post/from-cartesian-product-sql-join-performance/"},"publisher":{"@type":"Organization","name":"胡思乱","logo":{"@type":"ImageObject","url":"https://gaoxin19.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://gaoxin19.github.io/ accesskey=h title="胡思乱 (Alt + H)">胡思乱</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://gaoxin19.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://gaoxin19.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://gaoxin19.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://gaoxin19.github.io/>主页</a>&nbsp;»&nbsp;<a href=https://gaoxin19.github.io/post/>Posts</a></div><h1 class="post-title entry-hint-parent">从笛卡尔积看 SQL JOIN 性能</h1><div class=post-meta><span title='2025-08-21 12:10:38 +0800 CST'>2025-08-21</span>&nbsp;·&nbsp;6 分钟&nbsp;·&nbsp;Me</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#1-join%e7%9a%84%e7%bb%9f%e4%b8%80%e6%a8%a1%e5%9e%8b%e7%ac%9b%e5%8d%a1%e5%b0%94%e7%a7%af%e4%b8%8e%e8%bf%87%e6%bb%a4 aria-label="1. JOIN的统一模型：笛卡尔积与过滤">1. JOIN的统一模型：笛卡尔积与过滤</a></li><li><a href=#2-%e6%a0%b8%e5%bf%83%e8%af%af%e5%8c%ba%e7%bb%93%e6%9e%9c%e9%9b%86%e5%a4%a7%e5%b0%8f-vs-%e6%89%a7%e8%a1%8c%e6%88%90%e6%9c%ac aria-label="2. 核心误区：结果集大小 vs. 执行成本">2. 核心误区：结果集大小 vs. 执行成本</a></li><li><a href=#3-%e5%9c%ba%e6%99%af%e5%88%86%e6%9e%90%e5%90%8e%e5%8f%b0%e5%88%97%e8%a1%a8%e7%9a%84%e5%85%b3%e8%81%94%e7%ad%9b%e9%80%89 aria-label="3. 场景分析：后台列表的关联筛选">3. 场景分析：后台列表的关联筛选</a><ul><li><a href=#%e6%96%b9%e6%a1%88%e4%b8%80%e4%bd%bf%e7%94%a8 aria-label="方案一：使用 INNER JOIN (逻辑正确，性能最优)">方案一：使用 INNER JOIN (逻辑正确，性能最优)</a></li><li><a href=#%e6%96%b9%e6%a1%88%e4%ba%8c%e4%bd%bf%e7%94%a8 aria-label="方案二：使用 LEFT JOIN (逻辑误导，结果相同但意图不明)">方案二：使用 LEFT JOIN (逻辑误导，结果相同但意图不明)</a></li><li><a href=#left-join aria-label="LEFT JOIN 在此场景下的真正用途：状态标记">LEFT JOIN 在此场景下的真正用途：状态标记</a></li></ul></li><li><a href=#4-%e6%80%bb%e7%bb%93%e4%b8%8e%e5%ae%9e%e8%b7%b5%e5%bb%ba%e8%ae%ae aria-label="4. 总结与实践建议">4. 总结与实践建议</a><ul><li><a href=#%e7%ac%ac%e4%b8%80%e6%80%a7%e5%8e%9f%e7%90%86%e6%80%bb%e7%bb%93-key-takeaways aria-label="第一性原理总结 (Key Takeaways):">第一性原理总结 (Key Takeaways):</a></li></ul></li></ul></div></details></div><div class=post-content><h3 id=1-join的统一模型笛卡尔积与过滤><strong>1. JOIN的统一模型：笛卡尔积与过滤</strong><a hidden class=anchor aria-hidden=true href=#1-join的统一模型笛卡尔积与过滤>#</a></h3><p>要理解任何 <code>JOIN</code> 的性能，必须回归其最根本的数学模型。无论是 <code>INNER JOIN</code> 还是 <code>OUTER JOIN</code>，其逻辑上都可以分解为以下步骤：</p><ol><li><strong>生成组合 (Combination)</strong>：计算两张表的笛卡尔积（Cartesian Product），即 <code>表A行数 × 表B行数</code> 的全量组合。</li><li><strong>应用条件 (Filtering)</strong>：使用 <code>ON</code> 子句作为过滤器，在全量组合中筛选出满足条件的行。</li><li><strong>补充数据 (Augmentation - 仅外连接)</strong>：对于 <code>OUTER JOIN</code>，需要将“保留表”（如 <code>LEFT JOIN</code> 中的左表）中未能匹配的行补充回来，并将另一表的字段填充为 <code>NULL</code>。</li></ol><p>这个模型可以用以下流程图来概念化：</p><pre class=mermaid>
    ---
	config:
	  theme: neutral
	---
	flowchart TD
	    subgraph &#34;JOIN 逻辑模型&#34;
	        direction TB
	        A[&#34;表 A (M行)&#34;]
	        B[&#34;表 B (N行)&#34;]
	        
	        subgraph &#34;1. 组合&#34;
	            C((笛卡尔积 M*N))
	        end
	        
	        subgraph &#34;2. 过滤&#34;
	            F{ON 条件}
	        end
	
	        subgraph &#34;3. 补充 (外连接)&#34;
	            G[为A中未匹配行&lt;br/&gt;补NULL]
	        end
	
	        A --&gt; C
	        B --&gt; C
	        C --&gt; F
	        F -- 匹配 --&gt; D[匹配行]
	        F -- A中未匹配 --&gt; G
	
	        D --&gt; E_INNER[&lt;b&gt;INNER JOIN 结果&lt;/b&gt;]
	        D --&gt; E_LEFT[&lt;b&gt;LEFT JOIN 结果&lt;/b&gt;]
	        G --&gt; E_LEFT
	    end
</pre><p>虽然数据库的<strong>查询优化器 (Query Optimizer)</strong> 极少会真正执行一次完整的笛卡尔积，但这个模型是理解所有 <code>JOIN</code> 行为和性能问题的基石。</p><hr><h3 id=2-核心误区结果集大小-vs-执行成本><strong>2. 核心误区：结果集大小 vs. 执行成本</strong><a hidden class=anchor aria-hidden=true href=#2-核心误区结果集大小-vs-执行成本>#</a></h3><blockquote><p><em>这里外连接只用LEFT JOIN举例，相比 RIGHT JOIN 仅是左右的区别</em></p></blockquote><p><strong>常见误解</strong>：<code>LEFT JOIN</code> 的结果集通常 ≥ <code>INNER JOIN</code>，因此 <code>LEFT JOIN</code> 的开销更大。</p><p><strong>事实</strong>：查询性能的核心驱动因素是<strong>执行计划的成本 (Execution Cost)</strong>，而非最终结果集的大小。执行成本主要由 I/O、CPU 计算和内存使用决定。一个低效的执行计划，即使最终只返回一行数据，也可能扫描了数十亿行，其成本是巨大的。
<code>INNER JOIN</code> 和 <code>LEFT JOIN</code> 的关键性能差异，在于优化器选择执行计划的<strong>灵活性</strong>和<strong>确定性</strong>。</p><ul><li><p><strong><code>INNER JOIN</code></strong>：优化器拥有完全的自主权。它可以在 <code>A JOIN B</code> 和 <code>B JOIN A</code> 之间自由选择，决定哪张表作为<strong>驱动表 (Driving Table)</strong>，哪张作为<strong>被驱动表 (Driven Table)</strong>。如果优化器基于错误的统计信息做出了误判（例如，错误地将大表作为驱动表），就可能导致灾难性的性能。</p></li><li><p><strong><code>LEFT JOIN</code></strong>：优化器的选择在逻辑上受到了限制。<strong>左表天然就是驱动表</strong>。这个“限制”在某些场景下反而成了一种优势，因为它提供了一个稳定、可预测的执行路径：<strong>遍历左表的每一行，然后去右表进行查找</strong>。</p></li></ul><hr><h3 id=3-场景分析后台列表的关联筛选><strong>3. 场景分析：后台列表的关联筛选</strong><a hidden class=anchor aria-hidden=true href=#3-场景分析后台列表的关联筛选>#</a></h3><p>通过关联表筛选主列表（Bot与用户启用关系），这是一个典型的“多对多”关联查询场景。</p><ul><li><strong>数据模型</strong>:<ul><li><code>bots</code> 表: 包含所有可用的 Bot (id, name, &mldr;)。这是一个主数据列表。</li><li><code>bot_user_relations</code> 表: 记录了哪个用户启用了哪个 Bot (id, bot_id, user_id)。这是一个关联表。</li></ul></li><li><strong>新增需求</strong>: 在后台的“Bot 列表”页面，增加一个筛选条件，可以根据 <code>user_id</code> 查询出该用户已启用的所有 Bot。</li></ul><h4 id=方案一使用><strong>方案一：使用 <code>INNER JOIN</code> (逻辑正确，性能最优)</strong><a hidden class=anchor aria-hidden=true href=#方案一使用>#</a></h4><p>这个需求的本质是求两个集合的交集：“所有 Bot 的集合”与“某个特定用户启用的 Bot 的集合”。<code>INNER JOIN</code> 正是为此而生。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>b</span><span class=p>.</span><span class=o>*</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=n>bots</span><span class=w> </span><span class=n>b</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>INNER</span><span class=w> </span><span class=k>JOIN</span><span class=w> </span><span class=n>bot_user_relations</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>b</span><span class=p>.</span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>r</span><span class=p>.</span><span class=n>bot_id</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>WHERE</span><span class=w> </span><span class=n>r</span><span class=p>.</span><span class=n>user_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>123</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p><strong>执行计划分析:</strong>
这个查询的意图非常清晰，优化器可以轻松地制定出最高效的执行计划。假设 <code>bot_user_relations</code> 表的 <code>user_id</code> 字段上有索引：</p><ol><li><strong>驱动</strong>: 优化器会首先在 <code>bot_user_relations</code> 表上应用 <code>WHERE r.user_id = 123</code> 条件。通过 <code>user_id</code> 索引，它能以极高的速度定位到该用户启用的所有记录。这通常是一个非常小的数据集。</li><li><strong>连接</strong>: 然后，优化器会拿着这个小结果集中的 <code>bot_id</code>，去 <code>bots</code> 表中查找对应的 Bot 详细信息。由于是通过主键 <code>b.id</code> 进行连接，这个查找过程同样快如闪电。</li></ol><p><strong>结论</strong>: 这个方案的执行路径是“<strong>先过滤，再连接</strong>”。它从最小的数据集开始驱动整个查询，最大限度地减少了 I/O 和计算量，是实现该需求最理想的方式。</p><h4 id=方案二使用><strong>方案二：使用 <code>LEFT JOIN</code> (逻辑误导，结果相同但意图不明)</strong><a hidden class=anchor aria-hidden=true href=#方案二使用>#</a></h4><p>开发者有时会陷入一种思维定式：“我的主列表是 <code>bots</code> 表，所以我应该从它开始，用 <code>LEFT JOIN</code>。”</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>b</span><span class=p>.</span><span class=o>*</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=n>bots</span><span class=w> </span><span class=n>b</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>LEFT</span><span class=w> </span><span class=k>JOIN</span><span class=w> </span><span class=n>bot_user_relations</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>b</span><span class=p>.</span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>r</span><span class=p>.</span><span class=n>bot_id</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>WHERE</span><span class=w> </span><span class=n>r</span><span class=p>.</span><span class=n>user_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>123</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p><strong>执行计划分析:</strong>
<code>WHERE</code> 子句中对右表 <code>r</code> 的过滤条件 (<code>r.user_id = 123</code>)，会自动将所有在 <code>r</code> 表中没有匹配的行（这些行的 <code>r.user_id</code> 为 <code>NULL</code>）给排除掉。</p><p>因此，这个查询的<strong>最终结果集与 <code>INNER JOIN</code> 完全一致</strong>。</p><p>虽然现代优化器通常会将其重写为 <code>INNER JOIN</code> 并采用相同的最优执行计划，但这种写法存在问题：</p><ul><li><strong>代码意图不清晰</strong>: 代码表面上是想保留所有 <code>bots</code>，但实际上却是在做过滤。</li><li><strong>依赖优化器</strong>: 你将代码的正确性寄希望于优化器的智能，这是一个潜在的风险。在某些极端复杂的查询或特定数据库版本中，优化器可能无法做出最优转换，导致性能下降。</li></ul><h4 id=left-join><strong><code>LEFT JOIN</code> 在此场景下的真正用途：状态标记</strong><a hidden class=anchor aria-hidden=true href=#left-join>#</a></h4><p><code>LEFT JOIN</code> 在这里的正确用法不是筛选，而是<strong>为全量列表增加状态标记</strong>。例如，需求是：“<strong>显示所有 Bot，并标记出哪些是用户 123 启用的</strong>”。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>b</span><span class=p>.</span><span class=n>id</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>b</span><span class=p>.</span><span class=n>name</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>-- 如果 r.user_id 不为 NULL，说明关联成功，即用户已启用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=p>(</span><span class=k>CASE</span><span class=w> </span><span class=k>WHEN</span><span class=w> </span><span class=n>r</span><span class=p>.</span><span class=n>user_id</span><span class=w> </span><span class=k>IS</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=k>THEN</span><span class=w> </span><span class=s1>&#39;Yes&#39;</span><span class=w> </span><span class=k>ELSE</span><span class=w> </span><span class=s1>&#39;No&#39;</span><span class=w> </span><span class=k>END</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>is_enabled_by_user_123</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=n>bots</span><span class=w> </span><span class=n>b</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>LEFT</span><span class=w> </span><span class=k>JOIN</span><span class=w> </span><span class=n>bot_user_relations</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>b</span><span class=p>.</span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>r</span><span class=p>.</span><span class=n>bot_id</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>r</span><span class=p>.</span><span class=n>user_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>123</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p><strong>注意关键区别</strong>：<code>r.user_id = 123</code> 这个条件被移入了 <code>ON</code> 子句。</p><ul><li><strong><code>ON</code> 子句中的条件</strong>: 定义了“如何关联”。这里的意思是，不仅 <code>bot_id</code> 要匹配，<code>user_id</code> 也必须是 123，才算是一次成功的连接。</li><li><strong><code>WHERE</code> 子句中的条件</strong>: 定义了“如何过滤最终结果集”。</li></ul><p>这个查询会返回 <code>bots</code> 表中的所有记录，并通过一个额外的 <code>is_enabled</code> 字段清晰地展示了每个 Bot 对于特定用户的启用状态。这才是 <code>LEFT JOIN</code> 在此场景下强大而正确的应用。</p><hr><h3 id=4-总结与实践建议><strong>4. 总结与实践建议</strong><a hidden class=anchor aria-hidden=true href=#4-总结与实践建议>#</a></h3><p>哪种<code>JOIN</code>类型更快，并非普适规则，而是在特定条件下的必然结果。</p><table><thead><tr><th style=text-align:left>对比维度</th><th style=text-align:left><code>INNER JOIN</code></th><th style=text-align:left><code>LEFT JOIN</code></th></tr></thead><tbody><tr><td style=text-align:left><strong>核心逻辑</strong></td><td style=text-align:left>返回两表的交集</td><td style=text-align:left>返回左表全集，并附带右表的匹配信息</td></tr><tr><td style=text-align:left><strong>优化器行为</strong></td><td style=text-align:left><strong>灵活</strong>：可自由选择驱动表和连接算法（Hash, Nested Loop等）</td><td style=text-align:left><strong>受约束</strong>：左表在逻辑上强制为驱动表</td></tr><tr><td style=text-align:left><strong>性能优势场景</strong></td><td style=text-align:left><code>ON</code> 条件<strong>高选择性</strong>，能通过索引快速过滤掉大量数据</td><td style=text-align:left><strong>左表驱动</strong>为最优选择，且右表匹配<strong>稀疏</strong>或不确定</td></tr><tr><td style=text-align:left><strong>潜在风险</strong></td><td style=text-align:left>优化器可能因统计数据过时或复杂查询而<strong>选错执行计划</strong></td><td style=text-align:left>如果右表是小表，强制左表（大表）驱动可能<strong>并非最优</strong></td></tr></tbody></table><h4 id=第一性原理总结-key-takeaways><strong>第一性原理总结 (Key Takeaways):</strong><a hidden class=anchor aria-hidden=true href=#第一性原理总结-key-takeaways>#</a></h4><ol><li><strong>性能瓶颈在于过程，而非结果</strong>：始终关注 <code>EXPLAIN</code> 展示的执行计划，而不是结果集的行数。</li><li><strong><code>JOIN</code> 的性能核心在于“驱动”与“查找”的成本</strong>：选择最优的驱动表，并确保对被驱动表的查找是高效的（通常意味着利用索引）。</li><li><strong><code>LEFT JOIN</code> 的优势在于“确定性”</strong>：当你知道“扫描左表，查找右表”是最佳路径时，<code>LEFT JOIN</code> 能确保优化器就走这条路，从而避免了不确定性带来的风险。</li><li><strong>按需使用</strong>：不要因为潜在的性能优势而滥用 <code>LEFT JOIN</code>。如果你的业务逻辑只需要交集，就应该使用 <code>INNER JOIN</code>，并确保相关的列上有正确的索引，既要相信优化器的判断，也要善用 EXPLAIN 去验证它。</li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://gaoxin19.github.io/tags/sql/>SQL</a></li></ul><nav class=paginav><a class=prev href=https://gaoxin19.github.io/post/cursor-unsubscribe-10-months/><span class=title>« 上一页</span><br><span>订阅10个月后，和Cursor说再见</span>
</a><a class=next href=https://gaoxin19.github.io/post/cors_problems/><span class=title>下一页 »</span><br><span>跨域问题记录</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://gaoxin19.github.io/>胡思乱</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".post-content img"));images.forEach(e=>{mediumZoom(e,{margin:20,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.8)"})})</script><script type=module src=https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.esm.js></script><script nomodule src=https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.js></script><script type=text/javascript async src=https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js></script><script id=counterscale-script data-site-id=gx-github-pages src=https://counterscale.gx1nice.workers.dev/tracker.js defer></script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>